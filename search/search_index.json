{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pipeline Data Quality","text":"<p>Para garantir a qualidade dos dados no processo de ETL vamos seguir os seguintes passos:</p> <pre><code>graph TD;\n    A[Configura Vari\u00e1veis do Banco] --&gt; B[Ler Banco SQL];\n    B --&gt; E[Valida\u00e7\u00e3o do Schema de Entrada];\n    E --&gt;|Falha| X[Alerta de Erro de Entrada];\n    E --&gt;|Sucesso| T[Transforma KPIs];\n    T --&gt; S[Valida\u00e7\u00e3o Schema de Sa\u00edda];\n    S --&gt;|Falha| Z[Alerta de Erro de Sa\u00edda];\n    S--&gt;|Sucesso| F[Salvar no DuckDB]\n</code></pre>"},{"location":"#contratos-de-dados","title":"Contratos de Dados","text":"<p>               Bases: <code>DataFrameModel</code></p> <p>Define o esquema para a valida\u00e7\u00e3o de dados de produtos com Pandera.</p> <p>Este esquema inclui campos b\u00e1sicos para produtos, incluindo um campo de e-mail validado por uma express\u00e3o regular.</p> <p>Attributes:</p> Name Type Description <code>id_produto</code> <code>Series[int]</code> <p>Identificador do produto.</p> <code>nome</code> <code>Series[str]</code> <p>Nome do produto.</p> <code>quantidade</code> <code>Series[int]</code> <p>Quantidade dispon\u00edvel do produto, deve ser maior ou igual a 0.</p> <code>preco</code> <code>Series[float]</code> <p>Pre\u00e7o do produto, deve ser maior ou igual a 0.</p> <code>categoria</code> <code>Series[str]</code> <p>Categoria do produto.</p> <code>email</code> <code>Series[str]</code> <p>E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.</p> Source code in <code>app/schemas.py</code> <pre><code>class ProdutoSchema(pa.DataFrameModel):\n    \"\"\"\n    Define o esquema para a valida\u00e7\u00e3o de dados de produtos com Pandera.\n\n    Este esquema inclui campos b\u00e1sicos para produtos, incluindo um campo de e-mail\n    validado por uma express\u00e3o regular.\n\n    Attributes:\n        id_produto (Series[int]): Identificador do produto.\n        nome (Series[str]): Nome do produto.\n        quantidade (Series[int]): Quantidade dispon\u00edvel do produto, deve ser maior ou igual a 0.\n        preco (Series[float]): Pre\u00e7o do produto, deve ser maior ou igual a 0.\n        categoria (Series[str]): Categoria do produto.\n        email (Series[str]): E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.\n    \"\"\"\n\n    id_produto: Series[int]\n    nome: Series[str]\n    quantidade: Series[int] = pa.Field(ge=0)\n    preco: Series[float] = pa.Field(ge=0)\n    categoria: Series[str]\n    email: Series[str] = pa.Field(regex=email_regex)\n\n    class Config:\n        coerce = True\n        strict = True\n</code></pre> <p>               Bases: <code>ProdutoSchema</code></p> <p>Define o esquema para a valida\u00e7\u00e3o de dados de produtos com Pandera.</p> <p>Este esquema inclui campos b\u00e1sicos para produtos, incluindo um campo de e-mail validado por uma express\u00e3o regular.</p> <p>Attributes:</p> Name Type Description <code>id_produto</code> <code>Series[int]</code> <p>Identificador do produto.</p> <code>nome</code> <code>Series[str]</code> <p>Nome do produto.</p> <code>quantidade</code> <code>Series[int]</code> <p>Quantidade dispon\u00edvel do produto, deve ser maior ou igual a 0.</p> <code>preco</code> <code>Series[float]</code> <p>Pre\u00e7o do produto, deve ser maior ou igual a 0.</p> <code>categoria</code> <code>Series[str]</code> <p>Categoria do produto.</p> <code>email</code> <code>Series[str]</code> <p>E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.</p> <code>valor_total_estoque</code> <code>Series[float]</code> <p>quantidade * preco</p> <code>categoria_normalizada</code> <code>Series[str]</code> <p>Assume-se que a categoria ser\u00e1 uma string, n\u00e3o precisa de check espec\u00edfico al\u00e9m de ser uma string</p> <code>disponibilidade</code> <code>Series[bool]</code> <p>Disponibilidade \u00e9 um booleano, ent\u00e3o n\u00e3o precisa de check espec\u00edfico</p> Source code in <code>app/schemas.py</code> <pre><code>class ProductSchemaKPI(ProdutoSchema):\n    \"\"\"\n    Define o esquema para a valida\u00e7\u00e3o de dados de produtos com Pandera.\n\n    Este esquema inclui campos b\u00e1sicos para produtos, incluindo um campo de e-mail\n    validado por uma express\u00e3o regular.\n\n    Attributes:\n        id_produto (Series[int]): Identificador do produto.\n        nome (Series[str]): Nome do produto.\n        quantidade (Series[int]): Quantidade dispon\u00edvel do produto, deve ser maior ou igual a 0.\n        preco (Series[float]): Pre\u00e7o do produto, deve ser maior ou igual a 0.\n        categoria (Series[str]): Categoria do produto.\n        email (Series[str]): E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.\n        valor_total_estoque (Series[float]): quantidade * preco\n        categoria_normalizada (Series[str]): Assume-se que a categoria ser\u00e1 uma string, n\u00e3o precisa de check espec\u00edfico al\u00e9m de ser uma string\n        disponibilidade Series[bool]: Disponibilidade \u00e9 um booleano, ent\u00e3o n\u00e3o precisa de check espec\u00edfico\n    \"\"\"\n\n    valor_total_estoque: Series[float] = pa.Field(ge=0)\n    categoria_normalizada: Series[str]\n    disponibilidade: Series[bool]\n</code></pre>"},{"location":"#funcoes-de-etl","title":"Fun\u00e7\u00f5es de ETL","text":"<p>Extrai dados do banco de dados SQL usando a consulta fornecida.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>A consulta SQL para extrair dados.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Pandas contendo os dados extra\u00eddos.</p> Source code in <code>app/etl.py</code> <pre><code>@pa.check_output(ProdutoSchema, lazy=True)\ndef extract_db(query: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Extrai dados do banco de dados SQL usando a consulta fornecida.\n\n    Args:\n        query: A consulta SQL para extrair dados.\n\n    Returns:\n        Um DataFrame do Pandas contendo os dados extra\u00eddos.\n    \"\"\"\n    engine = get_engine()\n    with engine.connect() as conn, conn.begin():\n        return pd.read_sql_query(query, conn)\n</code></pre> <p>Transforma os dados do DataFrame aplicando c\u00e1lculos e normaliza\u00e7\u00f5es.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame do Pandas contendo os dados originais.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame do Pandas ap\u00f3s a aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.</p> Source code in <code>app/etl.py</code> <pre><code>@pa.check_input(ProdutoSchema, lazy=True)\n@pa.check_output(ProductSchemaKPI, lazy=True)\ndef transform(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Transforma os dados do DataFrame aplicando c\u00e1lculos e normaliza\u00e7\u00f5es.\n\n    Args:\n        df: DataFrame do Pandas contendo os dados originais.\n\n    Returns:\n        DataFrame do Pandas ap\u00f3s a aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.\n    \"\"\"\n    df[\"valor_total_estoque\"] = df[\"quantidade\"] * df[\"preco\"]\n    df[\"categoria_normalizada\"] = df[\"categoria\"].str.lower()\n    df[\"disponibilidade\"] = df[\"quantidade\"] &gt; 0\n\n    return df\n</code></pre> <p>Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame do Pandas para ser carregado no DuckDB.</p> required <code>table_name</code> <code>str</code> <p>Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.</p> required <code>db_file</code> <code>str</code> <p>Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.</p> <code>'my_duckdb.db'</code> Source code in <code>app/etl.py</code> <pre><code>@pa.check_input(ProductSchemaKPI, lazy=True)\ndef load_to_duckdb(df: pd.DataFrame, table_name: str, db_file: str = \"my_duckdb.db\"):\n    \"\"\"\n    Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.\n\n    Args:\n        df: DataFrame do Pandas para ser carregado no DuckDB.\n        table_name: Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.\n        db_file: Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.\n    \"\"\"\n    with duckdb.connect(database=db_file, read_only=False) as con:\n        con.register(\"df_temp\", df)\n        con.execute(f\"CREATE OR REPLACE TABLE {table_name} AS SELECT * FROM df_temp\")\n</code></pre>"},{"location":"pandera/","title":"Pandera","text":"<p>Pandera \u00e9 uma ferramenta usada para valida\u00e7\u00e3o de estrutura em formato DataFrame, sendo recomendado para Pandas, Polars, DuckDB, PySpark e etc. Sendo que essa ferramenta ainda pode ser usada para infer\u00eancia de Schema, o que ajuda a criar um processo de qualidade em Pipelines j\u00e1 existentes.</p> <p>Diferente do Pydantic que \u00e9 recomendado para estruturas mais simples, como objetos, tipos primitivos, API's e Dataframes menores (at\u00e9 1M de linhas), o Pandera vai ajudar com valida\u00e7\u00f5es maiores.</p> <p>Sendo que o Pandera ainda tr\u00e1s valida\u00e7\u00f5es \u00fateis para regras mais complexas, como valida\u00e7\u00f5es de hip\u00f3tese.</p> <p>Importante notar que essa ferramenta pode gerar impacto na velocidade da Pipeline, por\u00e9m trazendo uma maior seguran\u00e7a quanto a qualidade dos dados na pipeline!</p>"},{"location":"pandera/#validacao-com-strict","title":"Valida\u00e7\u00e3o com <code>strict</code>","text":"<p>Caso usarmos o valor <code>strict=True</code> em um schema do Pandera, s\u00f3 ser\u00e1 aceito pela valida\u00e7\u00e3o caso tenha exatamente o schema determinado. Caso contr\u00e1rio (tiver <code>strict=False</code>) colunas adicionais ser\u00e3o aceitas sem problemas.</p> <p>Ent\u00e3o para casos em que queremos ter certeza que os dados seguiram um formato expec\u00edfico usamos esse m\u00e9todo, caso s\u00f3 quisermos assegurar que aquelas colunas determinadas que precisamos est\u00e3o certas usamos o False.</p>"},{"location":"pandera/#validacao-em-modo-lazy","title":"Valida\u00e7\u00e3o em Modo <code>lazy</code>","text":"<p>Quando usamos o modo lazy todos os dados ser\u00e3o validados, sendo assim todos os dados ser\u00e3o lidos mesmo em caso de erro. O que n\u00e3o acontece no <code>lazy=False</code>, nesse caso no primeiro erro que ocorrer a aplica\u00e7\u00e3o j\u00e1 \u00e9 parada e retorna esse erro exclusivo.</p> <p>Sendo assim em conjuntos de dados grandes pode demorar mais, por\u00e9m temos a visualiza\u00e7\u00e3o de todos os erros.</p>"}]}